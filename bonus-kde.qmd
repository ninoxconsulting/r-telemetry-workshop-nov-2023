---
title: "Generating Kernel Density Estimates"
---



## Overview

In this module we will use caribou data to create home range estimates using kernal density and minimum convex polygons. 


```{r}
library(sf)
#install.packages("ks")
library(ks)
library(mapview)
library(ggdensity)


# read in sf object 
bou <- read_sf("clean_data/caribou.gpkg") 

bou <- st_coordinates(bou) |> 
   cbind(bou)|>
   select(X, Y, herd)

# 
# # create table with XYs 
# bouxy <- st_coordinates(bou) |> 
#    cbind(bou) |> 
#    st_drop_geometry()|>
#    select(X, Y, herd)
# 


```


```{r, mcp-hr, eval = FALSE}

# Basic Home range 

# 1. minimum convex hulls 

mcp <- st_convex_hull(st_union(bou ))
plot(mcp)
plot(bou$geom, col = "blue", add = T)

# this is not very representative so what other methods can we use. 

```

```{r, kernal-density-basic, eval = FALSE}

# 2. Kernal Density estimate. 

#We saw from earlier mapping we can generate plot with high density regions. 

p <- ggplot(data = bou) +
  geom_hdr(aes(x = X, y = Y, fill = herd)) + 
  scale_fill_viridis_d(option = "turbo") +
  coord_sf() + 
  theme_bw()



# we can expand this in more detail to capture the kernal density estimate 

kde  <- ggplot(data = bou) +
  geom_hdr(aes(x = X, y = Y, fill = herd), method = "kde") + 
  scale_fill_viridis_d(option = "turbo") +
  coord_sf() + 
  theme_bw()


# However, the method_*() function call is required to estimate HDRs with non-default estimator parameters.

kde2  <- ggplot(data = bou) +
  geom_hdr(aes(x = X, y = Y, fill = herd), method = method_kde(h = 1, adjust = 1/2)) + 
  scale_fill_viridis_d(option = "turbo") +
  #coord_sf() + 
  theme_bw()


kde3  <- ggplot(data = bou) +
  geom_hdr(aes(x = X, y = Y, fill = herd), method = method_kde(h = NULL)) + 
  scale_fill_viridis_d(option = "turbo") +
  #coord_sf() + 
  theme_bw()




? method_kde

parameters; 

- h = bandwidth.kernel()
- adjust 


resa <- get_hdr(bou, method = method_kde(adjust = 1/2))
str(res)

xx <- get_hdr(bou, method = method_kde(), probs = c(.975, .6, .2))

p + geom_hdr_lines()






#https://bookdown.org/egarpor/NP-UC3M/kde-i-kde.html

#https://cran.r-project.org/web/packages/ks/vignettes/kde.pdf


###################################################################
#
library(ks)

# set.seed(8192) 
# samp<-200 
# mus<-rbind(c(-2,2),c(0,0),c(2,-2)) 
# Sigmas<-rbind(diag(2),matrix(c(0.8,-0.72,-0.72,0.8),nrow=2),diag(2)) 
# cwt<-3/11 
# props<-c((1-cwt)/2,cwt,(1-cwt)/2) 
# x<-rmvnorm.mixt(n=samp,mus=mus,Sigmas=Sigmas,props=props)


x <- bou

# Kernal density 

# using = h ref 

Hpi1 <- Hpi(x=x)
Hpi2 <- Hpi.diag(x = x)


fhat.pi1 <-kde(x=x,H=Hpi1) 
fhat.pi2 <-kde(x=x,H=Hpi2)


plot(fhat.pi1)
plot(fhat.pi1)


```

# unconstrained Smoothed Cross Validation 

```{r}


Hscv1 <-Hscv(x=x)
Hscv2 <-Hscv.diag(x=x)



fhat.pi11<-kde(x=x,H=Hscv1) 
fhat.pi22<-kde(x=x,H=Hscv2)

plot(fhat.pi11)
plot(fhat.pi22)

```











