{
  "hash": "2a80f553eb8f28a522d547b5d2c71034",
  "result": {
    "markdown": "---\ntitle: \"Exploring Raster Data\"\nparams:\n  write: true\n---\n\n\n## Overview:\n\nIn this module we will explore raster data, and the available data sets which can be used in R for analysis. We will:\n\n-   prepare our study aoi to use with rasters\n\n-   extract DEM data through the **bcmaps** package\n\n-   generate DEM derived covariates,\n\n-   prepare a raster stack with all spatial layers generated to date.\n\n## Background: Rasters\n\nRaster data is information built on a standard grid. These can be characterized by the grid extent (xmin, xmax, ymin, ymax) and can have a coordinate system to orient them in space. Rasters are made up of cells or pixels, based on a resolution or cell size. Each cell contains a single value. The **terra** package contains many functions for manipulating and processing rasters.\n\nNote we will be using the BC Albers coordinate reference system (EPSG:3005). The advantages of this are 1) BCAlbers is an equal area projection across BC, 2) extent is marked using meters.\n\n## 1. Create a standard raster template.\n\nFor ease of calculations we will create a standard \"template\" raster which will form the basis for all our data analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read in the libraries needed\nlibrary(dplyr)\nlibrary(sf)\nlibrary(bcmaps)\nlibrary(terra)\n```\n:::\n\n\nRead in our AOI that we made and saved previously. We can then convert this to a raster with a resolution of given size. In this example we will select 25m.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read in the spatial file\nbou <- read_sf(\"clean_data/scott_herd_subset.gpkg\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# read in the aoi previously created\naoi <- read_sf(\"clean_data/scott_aoi.gpkg\")\n```\n:::\n\n\nWe can now convert our polygon to a raster object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a template raster with a resolution of 25m\ntemplate <- rast(aoi, resolution = 25, names = \"aoi\", vals = 0)\n```\n:::\n\n\nexport the raster template for later processing\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwriteRaster(template, \"clean_data/template.tif\", overwrite = TRUE)\n```\n:::\n\n\n## 2. Extract base data using the CDED data set\n\nNow we can use the **bcmaps** package to directly download digital elevation data from the [Canadian Digital Elevation Model CDED](https://rdrr.io/github/bcgov/bcmaps/man/cded.html). Within BC, this is largely equivalent to the TRIM DEM data set. We will use the **cded_terra** function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note this is downloaded in tiles which will be cached \ntrim_raw <- bcmaps::cded_terra(aoi)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nchecking your existing tiles for mapsheet 93o are up to date\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nchecking your existing tiles for mapsheet 94b are up to date\n```\n:::\n\n```{.r .cell-code}\ntrim_raw # note this is in WGS so we need to convert to 3005\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass       : SpatRaster \ndimensions  : 1660, 3062, 1  (nrow, ncol, nlyr)\nresolution  : 0.0002083333, 0.0002083333  (x, y)\nextent      : -123.6756, -123.0377, 55.67421, 56.02005  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat NAD83 (EPSG:4269) \nsource      : filecc4cf2799e.vrt \nname        : elevation \n```\n:::\n\n```{.r .cell-code}\nres(trim_raw)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.0002083333 0.0002083333\n```\n:::\n\n```{.r .cell-code}\n# reproject to match our raster template crs and extent\ntrim_3005 <- project(trim_raw, template)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# write out the individual raster\nwriteRaster(trim_3005, \"clean_data/dem.tif\", overwrite = TRUE) \n```\n:::\n\n\n## 3. Generate DEM derived covariates\n\nNow we can use the terrain functions within the **terra** package to generate some standard base layers derived from the DEM.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# generate slope \nrslope <- terrain(trim_3005, v = \"slope\", neighbors = 8, unit = \"degrees\") \n\n# generate aspect\naspect <- terrain(trim_3005, v = \"aspect\", neighbors = 8,  unit = \"degrees\") \n\n# generate topographic roughness index\ntri <- terrain(trim_3005, v = \"TRI\", neighbors = 8)\n\n# create a raster stack\nrstack <- c(trim_3005, rslope, aspect, tri)\n\nplot(rstack)\n```\n\n::: {.cell-output-display}\n![](06-raster-data_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nwrite our the individual rasters (.tif)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwriteRaster(rslope, \"clean_data/slope.tif\", overwrite = TRUE) \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwriteRaster(aspect, \"clean_data/aspect.tif\", overwrite = TRUE) \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nwriteRaster(tri, \"clean_data/tri.tif\", overwrite = TRUE) \n```\n:::\n\n\n\n## Your Turn\n\n1.  Explore what other covariates you can generate using the **terra::terrain** function. Hint use **?terrain** to see the help file.\n\n::: {.callout-tip collapse=\"true\"}\n## Solution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#There are a number of other options to select from including TPI, TRIriley, roughness, flowdir. \n#Use the ?terrain to find details on the parameters needed\n\n?terra::terrain\nroughness <-  terrain(trim_3005, v = \"roughness\") \nplot(roughness)\n```\n:::\n\n:::\n\n2.  Compare outputs of aspect which the neighbours parameter is adjusted. What difference does this make to the output and the time to process?\n\n::: {.callout-tip collapse=\"true\"}\n## Solution:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# generate aspect\naspect4 <- terrain(trim_3005, v = \"aspect\", neighbors = 4,  unit = \"degrees\") \n\n# generate aspect\naspect8 <- terrain(trim_3005, v = \"aspect\", neighbors = 8,  unit = \"degrees\") \n\n# use the window to check \nplot(aspect4)\nplot(aspect8)\n\n# Explore the change in metric if any\naspectrr <- terrain(trim_3005, v = \"aspect\", neighbors = 8,  unit = \"radians\") \n```\n:::\n\n:::\n",
    "supporting": [
      "06-raster-data_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}