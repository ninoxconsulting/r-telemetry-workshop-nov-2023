{
  "hash": "d401f5b5836bf9469945ae04c546c9e4",
  "result": {
    "markdown": "---\ntitle: \"Exploring Raster Data\"\n---\n\n\n## Overview:\n\nIn this module we will explore rasters data and the available datasets which can be used through R for analysis We will:\n\n-   prepare our study aoi to use with rasters\n\n-   extract DEM data through the **bcmaps** package\n\n-   generate DEM derived covariates,\n\n-   prepare a raster stack with all spatial layers generated to date.\n\n## Background: Rasters\n\nRaster data is information built on standard grid. These can be characterised by the grid extent (xmin, xmax, ymin, ymax) and can have a coordinate system to orient them in space. Rasters are made up of cells or pixals, based on a resolution or cell size. Each cell contains a single value. The **terra** package contains many function for manipulating and processing rasters.\n\nNote we will be using the BC Albers coordinate reference system (EPSG:3005). The advantages of this are 1) BCAlbers is an equal area projection across BC, 2) extent is marked using meters.\n\n## 1. Create a standard raster template.\n\nFor ease of calculations we will create a standard \"template\" raster which will form the basis for all our data analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read in the libraries needed\n\nlibrary(dplyr)\nlibrary(sf)\nlibrary(bcmaps)\nlibrary(terra)\n```\n:::\n\n\nRead in our basic aoi and extend it to the nearest 100m. We can then convert this to a raster with a resolution of given size. In this example we will select 25m.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# \n# # read in the spatial file \n# \n# bou <- st_read(file.path(\"clean_data/scott_herd_subset.gpkg\"), crs = 4326)\n# \n# # check this is not only output as a csv \n\n\n# read in the spatial file \n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# read in the aoi \naoi_raw <- st_read(file.path(\"clean_data\", \"scott_aoi.gpkg\"))\n\n# transform to BC Albers if needed. \naoi_3005 <- st_transform(aoi_raw, 3005)\n#crs(aoi_3005)\n\n# extend the aoi to the nearest 100m to provide a buffer \nbb <- sf::st_bbox(aoi_3005)\n\n## Generate expanded bbox -- expands to neared 100m\nxmin <- floor(bb$xmin / 100)*100\nxmax <- ceiling(bb[\"xmax\"] / 100) * 100\nymin <- floor(bb$ymin / 100)*100\nymax <- ceiling(bb[\"ymax\"] / 100) * 100\n\nbox <- matrix(c(xmin, ymin, xmin, ymax, xmax, ymax, xmax, ymin, xmin, ymin), ncol = 2, byrow = TRUE)\n\n# convert to a polygon\nbox <- sf::st_polygon(list(box))\n# assign a crs\nbox <- sf::st_sfc(box, crs=st_crs(aoi_3005))\n\n# convert to a sf object \naoi <- sf::st_as_sf(box)\n\n# Optional \n#st_write(aoi, file.path(\"clean_data\",\"scott_aoi_snap.gpkg\"), append = FALSE)\n```\n:::\n\n\nWe can now convert our polygon to a raster object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a template raster with a resolution of 25m\ntemplate <- terra::rast(aoi , resolution = 25)\n\n# create a column name\nnames(template) = \"aoi\"\n\n# assign all values to zero \nterra::values(template) <- 0\n\n# export the raster for later processing\nterra::writeRaster(template, file.path(\"clean_data\", \"template.tif\"), overwrite = TRUE)\n```\n:::\n\n\n## 2. Extract base data using the CDED dataset\n\nNow we can use the **bcmaps** package to directly download digital elevation data from the [Canadian Digital Elevation Model CDED](https://rdrr.io/github/bcgov/bcmaps/man/cded.html). Within BC, this is laregly equivalent to the TRIM DEM dataset. We will use the **cded_terra** function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# extract DEM raw data - Note this is downloaded in tiles which will be cached to avoid the need to redownload repeatedly \n\ntrim_raw <- bcmaps::cded_terra(aoi)\n\n# lets look at the raster\ntrim_raw\nres(trim_raw)\n\n# note this is in WGS so we need to convert to 3005\n# reproject to match our raster template crs and extent\n\ntrim_3005 <- project(trim_raw, template)\n\n# write out the individual raster\nterra::writeRaster(trim_3005, file.path(\"clean_data\", \"dem.tif\"), overwrite = TRUE) \n```\n:::\n\n\n## 3. Generate DEM derived covariates\n\nNow we can use the terrain functions within the terra package to generate some standard base layers derived from the DEM.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# generate slope \nrslope <- terra::terrain(trim_3005, v = \"slope\", neighbors = 8, unit = \"degrees\") \n\n# generate aspect\naspect <- terra::terrain(trim_3005, v = \"aspect\", neighbors = 8,  unit = \"degrees\") \n\n# generate topographic roughness index\ntri <- terra::terrain(trim_3005, v = \"TRI\", neighbors = 8)\n\n# create a raster stack\nrstack <- c(trim_3005, rslope, aspect, tri)\n\nplot(rstack)\n\n\n# write our the individual rasters\n\n#terra::writeRaster(rslope, file.path(out_path, \"slope.tif\"), overwrite = TRUE) \n#terra::writeRaster(aspect , file.path(out_path, \"aspect.tif\"), overwrite = TRUE) \n#terra::writeRaster(tri , file.path(out_path, \"tri.tif\"), overwrite = TRUE) \n```\n:::\n\n\n## Bonus Questions.\n\n1.  Explore what other covariates you can generate using the **terra::terrain** function. Hint use **?terrain** to bring up a help file.\n\n2.  Compare outputs of aspect which the neighbours parameter is adjusted. What difference does this make to the output and the time to process?\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}