{
  "hash": "444b549b701cc065ade53fdbc934e2b9",
  "result": {
    "markdown": "---\ntitle: \"Processing Base Vector Data\"\n---\n\n\n\n## Overview:\n\nIn this module we will post-process the vector data we prepared earlier to generate some additional covariates using the **terra** package. We will also prepare all data for the analysis. This includes  \n\n-   generating a road density layer\n\n-   calculating distance to water metrics\n\n-   converting our prepared vector to raster\n\n-   building a raster stack with all covariate data\n\n\n## 1. Calculate density of road network. \n\nOften we want to post-process our raw vector data to create more meaningful covariates in our analysis. In this case we are interested in the density of roads and how this might impact our caribou habitat choice. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# load in the libraries needed\n\nlibrary(bcdata)\nlibrary(sf)\nlibrary(dplyr)\n\n# read in raster template\ntemplate <- rast(file.path(\"clean_data\", \"template.tif\"))\n\n\n# ## THIS WILL ALREADY BE INCLUDED IN ANDYS SECTION \n# \n# roads <- bcdc_query_geodata(\"bb060417-b6e6-4548-b837-f9060d94743e\") %>% \n#   bcdata::filter(bcdata::INTERSECTS(aoi))  %>%\n#   bcdata::select(\"id\", \"ROAD_CLASS\", \"ROAD_SURFACE\") %>% \n#   collect() %>%\n#   dplyr::select(ROAD_SURFACE, ROAD_CLASS) %>% \n#         {if(nrow(.) > 0) { \n#   st_intersection(., aoi) %>% \n#       st_cast(\"MULTILINESTRING\") \n#     } else .} \n#   \n# st_write(roads, \"clean_data/roads.gpkg\")\n```\n:::\n\n\nWe can assume that the type of road will have a different impact on Caribou avoidance or predator use. We can assign a value based on the road type. In this case we will assign a higher value to roads used more frequently.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read in roads\nroads <- st_read(file.path(\"clean_data\", \"roads.gpkg\"))\n\n# assign a value to the roads based on estimated speed of travel or use\n\nroads <- roads %>% \n  mutate(rd_value = case_when(\n            ROAD_SURFACE == \"loose\" ~ 25,\n            ROAD_SURFACE == \"overgrown\" ~ 5,\n            ROAD_SURFACE == \"rough\" ~ 10,\n            ROAD_SURFACE == \"unknown\" ~ 7.5)) \n```\n:::\n\n\nNow we can convert this to a raster using the template we created already\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# convert roads to a raster \nrroads <- rasterize(roads, template, field = \"rd_value\" )\n\nplot(rroads)\n```\n:::\n\nAs the impact of the roads is likely to impact a wider influence than a single pixal we can use a moving window analysis to expand the influence of roads for a given value. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a moving window \nrrdens <- focal(rroads, w=9, fun=\"sum\", na.rm=TRUE)\n\nplot(rrdens)\n\nterra::writeRaster(rrdens, file.path(\"clean_data\", \"road_density.tif\"), overwrite = TRUE) \n```\n:::\n\n\n\n\n## 2. Calculate distance from water\n\nWhile density provides a measure of impact we may also be interested in capturing the distance of fixes to caribou points. In this case we will explore the distance to water bodies within the study areas. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read in water \nwater <- st_read(file.path(\"clean_data\", \"roads.gpkg\"))\n\n# calculate the distance to water for each pixal in the raster\n# be patient - this might take some time. \nwater_dis <- terra::distance(template, water, unit=\"km\")\n\nplot(water_dis)\n\n# what sort of values are we seeing?\nrange(water_dis)\nsort(unique(values(water_dis)))\nrange(unique(values(water_dis)))\n```\n:::\n\n\n\n## 3. Convert base vector data to rasters \n\nWe can also convert each vector layer we extracted into a raster. \n\n\nNote this can also be done at the vector stage, however predictive modelling will normally require a stacked covariate list so that you can predict from the built model \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# move this section to Andy; bc data section. \n\n\n\nvri <- bcdata::bcdc_query_geodata(\"2ebb35d8-c82f-4a17-9c96-612ac3532d55\") %>%\n      bcdata::filter(bcdata::INTERSECTS(aoi)) %>%\n      bcdata::select(c(\"PROJ_AGE_CLASS_CD_1\",\"BCLCS_LEVEL_4\",\"CROWN_CLOSURE_CLASS_CD\")) %>% \n      bcdata::collect()\n\n#(vri codes)[https://www2.gov.bc.ca/assets/gov/farming-natural-resources-and-industry/forestry/stewardship/forest-analysis-inventory/data-management/standards/vegcomp_poly_rank1_data_dictionaryv5_2019.pdf]\n\n\n# Tree coniferous leading - select coniferous leading vri plots\nvri_conif <- vri %>% \n    dplyr::mutate(conif = BCLCS_LEVEL_4) %>%\n    dplyr::filter(conif == \"TC\") %>%\n    dplyr::select(conif )\n\n#plot(vri_conif$BCLCS_LEVEL_4)\n\nst_write(vri_conif, file.path(\"clean_data\",\"vri_conif.gpkg\") , append = FALSE)\n\n\n# Age class greater than 40 years\nvri_ageclass <- vri %>%\n    dplyr::mutate(age_class = as.numeric(PROJ_AGE_CLASS_CD_1)) %>%\n    dplyr::filter(age_class >= 3) %>%\n    dplyr::select(age_class)\n\nst_write(vri_ageclass, file.path(\"clean_data\", \"vri_ageclass.gpkg\"), append = FALSE)\n \n\n# Crown closure class \nvri_cc <- vri %>%\n    dplyr::mutate(cc_class = as.numeric(CROWN_CLOSURE_CLASS_CD)) %>%\n    dplyr::select(cc_class)\nst_write(vri_cc, file.path(\"clean_data\", \"vri_cc.gpkg\"), append = FALSE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbec <- st_read(file.path(\"clean_data\",\"bec.gpkg\"))\nvri_cc <- st_read(file.path(\"clean_data\",\"vri_cc.gpkg\"))\nvri_conif <- st_read(file.path(\"clean_data\",\"vri_conif.gpkg\"))\nvri_ageclass <- st_read(file.path(\"clean_data\",\"vri_ageclass.gpkg\"))\n#water\n#roads \n#cutblocks\n\n\n\n\n# convert to rasters\nvri_cc <- rasterize(vri_cc, template, field = \"cc_class\" )\nvri_conif <- rasterize(vri_conif, template, field = \"conif\" )\nvri_ageclass <- rasterize(vri_ageclass, template, field = \"age_class\" )\n\n\n# stack into a set of rasters\nvect_stack <- c(vri_cc, vri_conif, vri_ageclass, water_dis, rrdens)\n```\n:::\n\n\n## Lets combine our already created rasters \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrslope <- rast(file.path(\"clean_data\",\"slope.gpkg\"))\naspect <- rast(file.path(\"clean_data\",\"aspect.gpkg\"))\ntri  <- rast(file.path(\"clean_data\",\"tri.gpkg\"))\ntrim_3005 <- rast(file.path(\"clean_data\",\"dem.gpkg\"))\n\n\n\n# create a raster stack\nrast_stack <- c(trim_3005, rslope, aspect, tri)\n```\n:::\n\n\n\n## 4. Combine raster layers into a stack \n\n\n\n# lets combine both the raster stack and the vector stack \n\nall_stack <- c(vect_stack, rast_stack)\n\nplot(all_stack)\n\n# we can write this out as a tif (raster object) \n#writeRaster(all_stack, file.path(\"clean_data\", \"rstack.tif\"), overwrite = T)\n\n\n## or we can write this out to a very small R object \n\nsaveRDS(all_stack, file.path(\"clean_data\", \"covars.RDS\")) # much faster\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}