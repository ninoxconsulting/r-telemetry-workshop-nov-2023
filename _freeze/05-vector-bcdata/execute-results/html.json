{
  "hash": "35a206cdfe8e92c10d1ba55be7808e59",
  "result": {
    "markdown": "---\ntitle: \"Exploring the BC Data Catalogue with R\"\n---\n\n\n## Vector\n\n\nBasic list, not exclusive. bu fine for demo purpose\n\n1) VRI  - gen to fiddle with this a little. \n2) Roads\n3) water lakes/wetlands\n4) water stream\n5) disturbance - cutblocks < 30yrs \n\n\n\n\n6) fIRE AND FIRE INTENSITY? PERHAPS WE CAN SHELVE THIS?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(bcdata)\nlibrary(sf)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nbcdc_search(\"caribou\", n = 5)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nFound 43 matches. Returning the first 5.\nTo see them all, rerun the search and set the 'n' argument to 43.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nList of B.C. Data Catalogue Records\nNumber of records: 5\nTitles:\n1: Causes of Caribou Mortality (other)\n ID: 64ff3af9-50c4-4914-a276-777b37eab2a2\n Name: causes-of-caribou-mortality\n2: Boreal Caribou Habitat Data\nThis record has no resources. bcdata will not be able to access any\n data.\n ID: 9cd36e31-8981-4ba3-bc2c-ae355b2c9e4e\n Name: boreal-caribou-habitat-data\n3: Caribou in British Columbia (other)\n ID: c95424ee-009b-4ecf-b0af-c3eb1065055f\n Name: caribou-in-british-columbia\n4: Itcha Ilgachuz Caribou Habitat Area (multiple, wms, kml)\n ID: 6e58aa4d-7e29-4a0e-8ca4-66752d9355db\n Name: itcha-ilgachuz-caribou-habitat-area\n5: Caribou Herd Locations for BC (multiple, wms, kml, arcgis_rest)\n ID: 2b217585-f48d-4d9f-b7ba-746909ac35ca\n Name: caribou-herd-locations-for-bc\n\nAccess a single record by calling `bcdc_get_record(ID)` with the ID\n from the desired record.\n```\n:::\n:::\n\n\n## Create an Area of Interest (AOI)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nscott <- read_sf(\"clean_data/caribou.shp\") |> \n  filter(commnts == \"Scott\")\n\nscott_aoi <- st_bbox(scott) |> \n  st_as_sfc()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nst_write(scott_aoi, \"clean_data/scott_aoi.gpkg\")\n```\n:::\n\n\n## Bec: \n\n <!-- # # 1) BEC Biogeographical linework -->\n <!--  bec <- bcdc_query_geodata(\"f358a53b-ffde-4830-a325-a5a03ff672c3\") %>% -->\n <!--    bcdata::filter(INTERSECTS(in_aoi)) %>% -->\n <!--    bcdata::collect() %>% -->\n <!--    dplyr::select(MAP_LABEL) %>% -->\n <!--    {if(nrow(.) > 0) st_intersection(., in_aoi) else .} -->\n\n <!--  if(sf::st_crs(in_aoi) == st_crs(bec)){ -->\n\n <!--  st_write(bec, file.path(out_path, \"bec.gpkg\"), append = FALSE) -->\n \n \n ## Cutblocks\n \n  <!-- # 6. download cutblocks -->\n\n  <!-- get_harvest <- function(in_aoi, out_path) { -->\n\n  <!--   file_already_exists <- file.exists(file.path(out_path, \"cutblocks.gpkg\")) -->\n\n  <!--   if(overwrite == FALSE & file_already_exists == TRUE) { -->\n\n  <!--     message(\"\\r cutblocks already exists, skipping download\") -->\n\n  <!--   } else { -->\n\n  <!--     message(\"\\rDownloading cutblock layers\") -->\n\n  <!--     cutblocks <- bcdata::bcdc_query_geodata(\"b1b647a6-f271-42e0-9cd0-89ec24bce9f7\") %>% -->\n  <!--       bcdata::filter(bcdata::INTERSECTS(in_aoi)) %>% -->\n  <!--       bcdata::select(c(\"HARVEST_YEAR\")) %>% -->\n  <!--       bcdata::collect() -->\n\n  <!--   if (all(is.na(cutblocks)) || nrow(cutblocks) == 0) { -->\n  <!--       print(\"No recent cutblocks disturbance in area of interest\") } else { -->\n  <!--   sf::st_write(cutblocks, file.path(out_path, \"cutblocks.gpkg\"), append = FALSE) -->\n  <!--       } -->\n\n  <!--   } -->\n  <!--   return(TRUE) -->\n  <!--   } -->\n\n\n## Fire Perim.\n\n\n\n<!--   get_fires <- function(in_aoi, out_path) { -->\n\n<!--     fire_exists <- file.exists(file.path(out_path, \"fire.gpkg\")) -->\n\n<!--     if(overwrite == FALSE & fire_exists == TRUE) { -->\n\n<!--       message(\"\\rfirealready exists, skipping download, select overwrite = TRUE to force download of water layers\") -->\n\n<!--     } else { -->\n\n<!--       message(\"\\rDownloading fire disturbance\") -->\n\n<!--       # check the sticky columns -->\n<!--       #ff<- bcdc_describe_feature(\"cdfc2d7b-c046-4bf0-90ac-4897232619e1\") -->\n\n<!--       fire_records <- c(\"cdfc2d7b-c046-4bf0-90ac-4897232619e1\", -->\n<!--                         \"22c7cb44-1463-48f7-8e47-88857f207702\") -->\n\n<!--       fires_all <- NA ## placeholder -->\n\n<!--       for (i in 1:length(fire_records)) { -->\n<!--         #i = 2 -->\n<!--         fires <- bcdata::bcdc_query_geodata(fire_records[i]) %>% -->\n<!--           bcdata::filter(bcdata::INTERSECTS(in_aoi)) %>% -->\n<!--           bcdata::select(id, FIRE_YEAR)%>% -->\n<!--           collect() %>% -->\n<!--           {if(nrow(.) > 0) sf::st_intersection(., in_aoi) else .} -->\n\n<!--         if(nrow(fires) > 0) { -->\n<!--           ## bind results of loops -->\n<!--           if (i == 1) { -->\n<!--             fires_all <- fires } else { ## i > 1 -->\n<!--               if(all(is.na(fires_all))) {fires_all <- fires } else {fires_all <- rbind(fires_all, fires)} -->\n<!--             } -->\n<!--         } #else {print(\"No fires in layer queried\") } -->\n\n<!--         # rm(fires) -->\n<!--       } ## end loop -->\n\n\n<!--       if (all(is.na(fires_all)) || nrow(fires_all) == 0) { -->\n<!--         print(\"No recent fire disturbance in area of interest\") } else { -->\n<!--           sf::st_write(fires_all, file.path(out_path, \"fire.gpkg\"), append = FALSE) -->\n<!--         } -->\n\n<!--       } -->\n<!--       return(TRUE) -->\n<!--     } -->\n\n\n\n\n\n\n## fire intensity\n\n<!--   get_fire_intensity <- function(in_aoi, out_path) { -->\n\n<!--     fire_int_exists <- file.exists(file.path(out_path, \"fire_int.gpkg\")) -->\n\n<!--     if(overwrite == FALSE & fire_int_exists == TRUE) { -->\n\n<!--       message(\"\\r fire intensity already exists, skipping download, select overwrite = TRUE to force download of water layers\") -->\n\n<!--     } else { -->\n\n<!--       message(\"\\rDownloading fire intensity\") -->\n<!--       # check the sticky columns -->\n<!--       #ff<- bcdc_describe_feature(\"cdfc2d7b-c046-4bf0-90ac-4897232619e1\") -->\n\n<!--       fire_int_records <- c(\"c58a54e5-76b7-4921-94a7-b5998484e697\", -->\n<!--                         \"04c5ad28-d8eb-4c49-90c5-48b9b98fdfe9\") -->\n\n<!--       fires_int_all <- NA ## placeholder -->\n\n<!--       for (i in 1:length(fire_int_records)) { -->\n<!--         #i = 1 -->\n<!--         fires_int <- bcdata::bcdc_query_geodata(fire_int_records[i]) %>% -->\n<!--           bcdata::filter(bcdata::INTERSECTS(in_aoi)) %>% -->\n<!--           bcdata::select(id, FIRE_YEAR, BURN_SEVERITY_RATING)%>% -->\n<!--           bcdata::filter(BURN_SEVERITY_RATING %in% c(\"High\", \"Medium\")) %>% -->\n<!--           collect() %>% -->\n<!--           {if(nrow(.) > 0) sf::st_intersection(., in_aoi) else .} -->\n\n<!--         if(nrow(fires_int) > 0) { -->\n<!--           ## bind results of loops -->\n<!--           if (i == 1) { -->\n<!--             fires_int_all <- fires_int } else { ## i > 1 -->\n<!--               if(all(is.na(fires_int_all))) {fires_int_all <- fires_int } else {fires_int_all <- rbind(fires_int_all, fires_int)} -->\n<!--             } -->\n<!--         } -->\n\n<!--       } ## end loop -->\n\n\n<!--       if (all(is.na(fires_int_all)) || nrow(fires_int_all) == 0) { -->\n<!--         print(\"No recent fire intensity in area of interest\") } else { -->\n<!--           sf::st_write(fires_int_all, file.path(out_path, \"fire_int.gpkg\"), append = FALSE) -->\n<!--         } -->\n\n<!--     } -->\n<!--     return(TRUE) -->\n<!--   } -->\n\n\n\n\n## stream index\n\n  <!-- get_streams <- function(in_aoi, out_path) { -->\n\n  <!--   streams_exists <- file.exists(file.path(out_path, \"streams.gpkg\")) -->\n\n  <!--   if(overwrite == FALSE & streams_exists == TRUE) { -->\n\n  <!--     message(\"\\r streams already exists, skipping download, select overwrite = TRUE to force download of water layers\") -->\n\n  <!--   } else { -->\n\n  <!--   message(\"\\rDownloading streams\") -->\n\n  <!-- #streamd <- bcdc_describe_feature(\"92344413-8035-4c08-b996-65a9b3f62fca\") -->\n  <!-- streams <- bcdata::bcdc_query_geodata(\"92344413-8035-4c08-b996-65a9b3f62fca\") %>% -->\n  <!--   bcdata::filter(bcdata::INTERSECTS(in_aoi)) %>% -->\n  <!--   bcdata::select(c(id, STREAM_ORDER)) %>% -->\n  <!--   bcdata::collect() -->\n\n  <!-- if(length(st_is_empty(streams)) > 0 ){ -->\n  <!--   streams <- streams %>% dplyr::select(c(\"id\", \"STREAM_ORDER\"))%>% -->\n  <!--     sf::st_zm() -->\n\n  <!--  sf::st_write(streams, file.path(out_path, \"streams.gpkg\"), append = FALSE) -->\n  <!--   } -->\n  <!-- } -->\n\n  <!--   return(TRUE) -->\n  <!--     } -->\n\n\n\n## water bodies\n\n\n<!--  get_water <- function(in_aoi, out_path) { -->\n\n<!--     water_exists <- file.exists(file.path(out_path, \"lakes.gpkg\")) -->\n\n<!--     if(overwrite == FALSE & water_exists == TRUE) { -->\n\n<!--       message(\"\\rwater already exists, skipping download, select overwrite = TRUE to force download of water layers\") -->\n\n<!--     } else { -->\n\n\n<!--       message(\"\\rDownloading lake, streams and wetland layers\") -->\n\n<!--       ## LAKES ## -->\n\n<!--       # 1 Square Kilometer = 100.00 Hectare -->\n\n<!--       # Uses date filter which filters lakes -->\n<!--       lakes <- bcdata::bcdc_query_geodata(\"cb1e3aba-d3fe-4de1-a2d4-b8b6650fb1f6\") %>% -->\n<!--         bcdata::filter(bcdata::INTERSECTS(in_aoi)) %>% -->\n<!--         bcdata::select(id, WATERBODY_TYPE, AREA_HA) %>% -->\n<!--         bcdata::collect() -->\n\n<!--       if(length(st_is_empty(lakes)) > 0 ){ -->\n<!--       lakes <- lakes %>% dplyr::select(\"id\", \"WATERBODY_TYPE\", \"AREA_HA\") -->\n<!--       sf::st_write(lakes, file.path(out_path, \"lakes.gpkg\"), append = FALSE) -->\n<!--       } -->\n\n<!--   # download wetlands -->\n\n<!--       wetlands <- bcdata::bcdc_query_geodata(\"93b413d8-1840-4770-9629-641d74bd1cc6\") %>% -->\n<!--         bcdata::filter(bcdata::INTERSECTS(in_aoi)) %>% -->\n<!--         bcdata::select(id, WATERBODY_TYPE, AREA_HA) %>% -->\n<!--         bcdata::collect() -->\n\n<!--       wetlands <- wetlands %>% dplyr::filter(AREA_HA < 100) %>% -->\n<!--         dplyr::select(id, WATERBODY_TYPE, AREA_HA)%>% -->\n<!--         sf::st_union() -->\n\n<!--       if(length(st_is_empty(wetlands) > 0)){ -->\n<!--         sf::st_write(wetlands, file.path(out_path, \"wetlands.gpkg\"), append = FALSE) -->\n<!--       } -->\n\n<!--     } -->\n\n<!--       return(TRUE) -->\n<!--     } -->\n\n## roads\n\n\n<!-- get_roads <- function(in_aoi, out_path) { -->\n<!--   # The main road network layer has too many roads in it. Filter it down to only -->\n<!--   # include named roads and combine those with actual mapped FSR's -->\n\n<!--   message(\"\\rDownloading Road network\") -->\n<!--   roads <- bcdc_query_geodata(\"bb060417-b6e6-4548-b837-f9060d94743e\") %>% -->\n<!--     bcdata::filter(BBOX(local(st_bbox(in_aoi)))) %>% # slightly larger extent -->\n<!--     bcdata::select(id, ROAD_NAME_FULL, ROAD_CLASS, ROAD_SURFACE, FEATURE_LENGTH_M) %>% -->\n<!--     collect() %>% -->\n<!--     dplyr::select(id, ROAD_NAME_FULL,ROAD_SURFACE, ROAD_CLASS,FEATURE_LENGTH_M) %>% -->\n<!--        {if(nrow(.) > 0) { -->\n<!--       st_intersection(., in_aoi) %>% -->\n<!--        st_cast(\"MULTILINESTRING\") -->\n<!--     } else .} -->\n\n<!--   fsr <- bcdc_query_geodata(\"9e5bfa62-2339-445e-bf67-81657180c682\") %>% -->\n<!--     bcdata::filter( -->\n<!--       BBOX(local(st_bbox(in_aoi)))) %>% -->\n<!--     collect() %>% -->\n<!--     dplyr::select(id, FILE_TYPE_DESCRIPTION, FEATURE_LENGTH_M) %>% -->\n<!--     dplyr::rename(ROAD_CLASS = FILE_TYPE_DESCRIPTION) %>% -->\n<!--     dplyr::mutate(ROAD_CLASS = dplyr::case_when( -->\n<!--       ROAD_CLASS == \"Forest Service Road\" ~ \"resource\", -->\n<!--       ROAD_CLASS == \"Road Permit\" ~ \"unclassifed\")) %>% -->\n<!--     dplyr::mutate(ROAD_SURFACE = dplyr::case_when( -->\n<!--     ROAD_CLASS == \"resource\" ~ \"loose\", -->\n<!--     ROAD_CLASS == \"unclassifed\" ~ \"rough\")) %>% -->\n<!--     {if(nrow(.) > 0) { -->\n<!--       st_intersection(., in_aoi) %>% -->\n<!--         st_cast(\"MULTILINESTRING\") -->\n<!--     } else .} -->\n\n<!--   road_merge <- dplyr::bind_rows(roads, fsr) -->\n\n<!--   st_write(road_merge, file.path(out_path, \"road_network.gpkg\"), append = FALSE) -->\n<!-- } -->\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}