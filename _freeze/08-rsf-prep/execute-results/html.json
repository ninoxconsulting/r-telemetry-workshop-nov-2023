{
  "hash": "28aed9d2642245387b1fea3b584f4bf8",
  "result": {
    "markdown": "---\ntitle: \"Generate random sample points for RSF\"\n---\n\n\n\n## Overview:\n\nIn this module we use our prepared spatial data to generate the input datafiles to conduct a resource selection function analysis. This includes: \n\n-   generate a set of \"available\" or \"background points\" from our study area.\n-   extract spatial information for presence and available point locations\n-   export as table for future use\n-   use the extracted data to provide further graphics and summary options\n\n\n## Background: Resource Selection Functions\n\nNow that we have a cleaned and standardized dataset for the Scott Herd Caribou's we can prepare the data for further analysis.\n\nResource Selection Functions are a common method used to assess what is driving patterns of animal habitat preference. This process uses information or covariates (i.e. landscape attribute features) for locations where animals are present and compares them to the same features where animals are absent. In this way we can gather some information on what conditions (i.e. landscape, aspect, distance from road, etc) which contribute to higher habitat use. You can find more references for Resource Selection Functions below.\n\nWhile in this example we are concentrating on future analysis, the process of extracting background information for known locations can also provide meaningful summary statistics, i.e. proportion of locations within a specific BEC zone.\n\n\n## 1. Generate availalble location points.\n\nWe will generate a simple set of \"available\" based on the geographic distribution of the study area. Note you can limit this area in which you generate \"background\" points, using more sophisticated methods, such as within a kernal density or home range estimate.\n\nLets start by reading in the libraries we will use.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nlibrary(terra)\nlibrary(sf)\nlibrary(mapview)\nlibrary(ggplot2)\n```\n:::\n\n\nNext, read in the standardized data points for the Scott herd. If needed we can transform to BC Albers projection (EPGS:3005) to match our raster stack prepared in the previous step. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read in the aoi template \n\ntemplate <- rast(file.path(\"clean_data\",\"template.tif\"))\n\n\n# read in points \n\nbou_pts <- st_read(file.path(\"clean_data/scott_herd_subset.gpkg\")) \nbou_pts <- st_transform(bou_pts, 3005)\n\n\n# Lets keep only the important columns and add a \"presence/absence\" column. \n\nbou_pts <- bou_pts %>% \n  dplyr::select(animal.id, jdate)%>%\n  mutate(pres_abs = 1)\n```\n:::\n\n\n\nWe can use the **spatSample** function to generate random points for our given study area. This function has many more options which can be reviewed by using : **?spatSample** in the console. \n\nLets generate a set of points the same length as our \"presence\" locations using a \"random\" method. \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Generate random points for RSF use areas.\nset.seed(123)\navail_points <- spatSample(template, size = 2906, as.points = TRUE, na.rm = TRUE, method = \"random\")\n\navail_points <- st_as_sf(avail_points)\n\n# lets rename the column to make it clear these are background points \navail_points <- avail_points %>%\n  rename(\"pres_abs\" = lyr.1 )\n```\n:::\n\n\nWe can do a quick review fo the points to see what they look like using mapview.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmapview(avail_points) +\nmapview(bou_pts, color = \"red\", cex= 3)\n```\n:::\n\n\n\nWe can now combine our caribou locations and \"available\" locations into a single dataset. We will retain the spatial information to allow us to easily extract the values in the corresponding raster stack \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\navail_points \n\n\nbou_pts\n\n# note we have slightly different column headers \"geom\" vs \"geometry\" \nst_geometry(avail_points) = \"geom\" \n\n\nallpts <- bind_rows(bou_pts, avail_points ) \n```\n:::\n\n\n\nNext, we can read in our prepared raster stack as an .rds object. We can now use the **extract** function from the **terra** package to extract information for all layers in the raster stack for each of our points.  \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read in the raster stack \n\nrstack <- readRDS(file.path(\"clean_data\", \"covars.RDS\"))\n\n\n# extract all values in the raster stack for each location in the bou_pts file. \n\natts <- terra::extract(rstack, allpts)\n\n\n# remove unused columns \n\nbou_full_pts <- cbind( allpts, atts) %>%\n  select(-ID)\n\n\n# export this as spatial file # or \n\n\nbou_table <- bou_full_pts %>%\n  cbind(st_coordinates(.)) %>%\n  st_drop_geometry()\n\n\n# write out as csv \n\nwrite.csv(bou_table, file.path(\"clean_data\", \"allpts_att.csv\"))\n```\n:::\n\n\n\n# Summary of the extracted Point Values\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# tri - good overlap\n\nggplot(bou_table, aes(aspect)) +\n  geom_histogram(binwidth = 20) +\n  facet_wrap(~pres_abs)\n\n\nggplot(bou_table, aes(lyr.1)) +\n  geom_histogram(binwidth = 0.5) +\n  facet_wrap(~pres_abs)\n```\n:::\n\n\n\n\n\n\n\n\n## OPTIONAL \n\n## Build a mask with the \"occurance point\" (optional)\n\n\n::: {.cell}\n\n```{.r .cell-code}\noccur_raster <- rasterize(bou_pts, template, field = \"pres_abs\")\ntemplate_mask <- terra::mask(template, occur_raster, inverse = TRUE)\n\nplot(template_mask)\n```\n:::\n\n\n\n\n\n# Reference\n\n## add RSF refs\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}